
nomis-memory-game.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004c8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000004c8  0000055c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000007  00800062  00800062  0000055e  2**0
                  ALLOC
  3 .stab         00000960  00000000  00000000  00000560  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001f7  00000000  00000000  00000ec0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000010b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000096  00000000  00000000  000010d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000007ce  00000000  00000000  0000116d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000286  00000000  00000000  0000193b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000553  00000000  00000000  00001bc1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000080  00000000  00000000  00002114  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000001a4  00000000  00000000  00002194  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000059c  00000000  00000000  00002338  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000168  00000000  00000000  000028d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
   6:	26 c0       	rjmp	.+76     	; 0x54 <__bad_interrupt>
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
   a:	24 c0       	rjmp	.+72     	; 0x54 <__bad_interrupt>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>

0000001e <__ctors_end>:
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf e5       	ldi	r28, 0x5F	; 95
  24:	d2 e0       	ldi	r29, 0x02	; 2
  26:	de bf       	out	0x3e, r29	; 62
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_copy_data>:
  2a:	10 e0       	ldi	r17, 0x00	; 0
  2c:	a0 e6       	ldi	r26, 0x60	; 96
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e8 ec       	ldi	r30, 0xC8	; 200
  32:	f4 e0       	ldi	r31, 0x04	; 4
  34:	02 c0       	rjmp	.+4      	; 0x3a <.do_copy_data_start>

00000036 <.do_copy_data_loop>:
  36:	05 90       	lpm	r0, Z+
  38:	0d 92       	st	X+, r0

0000003a <.do_copy_data_start>:
  3a:	a2 36       	cpi	r26, 0x62	; 98
  3c:	b1 07       	cpc	r27, r17
  3e:	d9 f7       	brne	.-10     	; 0x36 <.do_copy_data_loop>

00000040 <__do_clear_bss>:
  40:	10 e0       	ldi	r17, 0x00	; 0
  42:	a2 e6       	ldi	r26, 0x62	; 98
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	a9 36       	cpi	r26, 0x69	; 105
  4c:	b1 07       	cpc	r27, r17
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	cc d0       	rcall	.+408    	; 0x1ea <main>
  52:	38 c2       	rjmp	.+1136   	; 0x4c4 <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <led_display>:
 * LEDS, MUST be on pins 0, 1 and 2 on any PORT. However, this can be changed by
 * changing the encodings.
 */
uint8_t led_display(uint8_t state)
{
    switch (state) {
  56:	82 30       	cpi	r24, 0x02	; 2
  58:	51 f0       	breq	.+20     	; 0x6e <led_display+0x18>
  5a:	83 30       	cpi	r24, 0x03	; 3
  5c:	18 f4       	brcc	.+6      	; 0x64 <led_display+0xe>
  5e:	81 30       	cpi	r24, 0x01	; 1
  60:	71 f4       	brne	.+28     	; 0x7e <led_display+0x28>
  62:	07 c0       	rjmp	.+14     	; 0x72 <led_display+0x1c>
  64:	84 30       	cpi	r24, 0x04	; 4
  66:	39 f0       	breq	.+14     	; 0x76 <led_display+0x20>
  68:	88 30       	cpi	r24, 0x08	; 8
  6a:	49 f4       	brne	.+18     	; 0x7e <led_display+0x28>
  6c:	06 c0       	rjmp	.+12     	; 0x7a <led_display+0x24>
  6e:	84 e0       	ldi	r24, 0x04	; 4
  70:	08 95       	ret
  72:	83 e0       	ldi	r24, 0x03	; 3
  74:	08 95       	ret
  76:	86 e0       	ldi	r24, 0x06	; 6
  78:	08 95       	ret
        break;
    case 0x02:
        return 0x04;
        break;
    case 0x04:
        return 0x06;
  7a:	81 e0       	ldi	r24, 0x01	; 1
  7c:	08 95       	ret
        break;
    case 0x08:
        return 0x01;
  7e:	80 e0       	ldi	r24, 0x00	; 0
        break;
    default:
        return 0x00;
        break;
    }
}
  80:	08 95       	ret

00000082 <cascade_leds>:
 *
 * \brief Cascade the output LEDs on and off using POV.
 *        Used for the idle gamestate.
 */
void cascade_leds()
{
  82:	1f 93       	push	r17
  84:	cf 93       	push	r28
  86:	df 93       	push	r29
    /// Predefinition of the for loop variable... Saves memory
    static uint16_t i = 0;
    static uint8_t up = 1;
   
    PORTB |= led_display(0x01 << i);
  88:	18 b3       	in	r17, 0x18	; 24
  8a:	c0 91 65 00 	lds	r28, 0x0065
  8e:	d0 91 66 00 	lds	r29, 0x0066
  92:	81 e0       	ldi	r24, 0x01	; 1
  94:	90 e0       	ldi	r25, 0x00	; 0
  96:	0c 2e       	mov	r0, r28
  98:	02 c0       	rjmp	.+4      	; 0x9e <cascade_leds+0x1c>
  9a:	88 0f       	add	r24, r24
  9c:	99 1f       	adc	r25, r25
  9e:	0a 94       	dec	r0
  a0:	e2 f7       	brpl	.-8      	; 0x9a <cascade_leds+0x18>
  a2:	d9 df       	rcall	.-78     	; 0x56 <led_display>
  a4:	18 2b       	or	r17, r24
  a6:	18 bb       	out	0x18, r17	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  a8:	88 ea       	ldi	r24, 0xA8	; 168
  aa:	91 e6       	ldi	r25, 0x61	; 97
  ac:	01 97       	sbiw	r24, 0x01	; 1
  ae:	f1 f7       	brne	.-4      	; 0xac <cascade_leds+0x2a>
    _delay_ms(100);
    PORTB &= 0xF0;
  b0:	88 b3       	in	r24, 0x18	; 24
  b2:	80 7f       	andi	r24, 0xF0	; 240
  b4:	88 bb       	out	0x18, r24	; 24
  b6:	84 ed       	ldi	r24, 0xD4	; 212
  b8:	90 e3       	ldi	r25, 0x30	; 48
  ba:	01 97       	sbiw	r24, 0x01	; 1
  bc:	f1 f7       	brne	.-4      	; 0xba <cascade_leds+0x38>
    _delay_ms(50);

    if (i == 3)
  be:	c3 30       	cpi	r28, 0x03	; 3
  c0:	d1 05       	cpc	r29, r1
  c2:	19 f4       	brne	.+6      	; 0xca <cascade_leds+0x48>
        up = 0;
  c4:	10 92 60 00 	sts	0x0060, r1
  c8:	05 c0       	rjmp	.+10     	; 0xd4 <cascade_leds+0x52>
    else if (i == 0)
  ca:	20 97       	sbiw	r28, 0x00	; 0
  cc:	19 f4       	brne	.+6      	; 0xd4 <cascade_leds+0x52>
        up = 1;
  ce:	81 e0       	ldi	r24, 0x01	; 1
  d0:	80 93 60 00 	sts	0x0060, r24

    if (up)
  d4:	80 91 60 00 	lds	r24, 0x0060
  d8:	88 23       	and	r24, r24
  da:	11 f0       	breq	.+4      	; 0xe0 <cascade_leds+0x5e>
        i += 1;
  dc:	21 96       	adiw	r28, 0x01	; 1
  de:	01 c0       	rjmp	.+2      	; 0xe2 <cascade_leds+0x60>
    else
        i -= 1;
  e0:	21 97       	sbiw	r28, 0x01	; 1
  e2:	d0 93 66 00 	sts	0x0066, r29
  e6:	c0 93 65 00 	sts	0x0065, r28
}
  ea:	df 91       	pop	r29
  ec:	cf 91       	pop	r28
  ee:	1f 91       	pop	r17
  f0:	08 95       	ret

000000f2 <blink_leds>:

void blink_leds() {
  f2:	bf 92       	push	r11
  f4:	cf 92       	push	r12
  f6:	df 92       	push	r13
  f8:	ef 92       	push	r14
  fa:	ff 92       	push	r15
  fc:	0f 93       	push	r16
  fe:	1f 93       	push	r17
 100:	cf 93       	push	r28
 102:	df 93       	push	r29
 104:	ee 24       	eor	r14, r14
 106:	ff 24       	eor	r15, r15
    uint16_t j;
    uint16_t i;
    for( i = 0; i < 100; i++) {
        for (j = 0; j <= 3; j++) {
            set_display(0x01 << j);
 108:	91 e0       	ldi	r25, 0x01	; 1
 10a:	c9 2e       	mov	r12, r25
 10c:	d1 2c       	mov	r13, r1
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 10e:	81 e2       	ldi	r24, 0x21	; 33
 110:	b8 2e       	mov	r11, r24
 112:	03 e0       	ldi	r16, 0x03	; 3
 114:	1f c0       	rjmp	.+62     	; 0x154 <blink_leds+0x62>
 116:	18 b3       	in	r17, 0x18	; 24
 118:	c6 01       	movw	r24, r12
 11a:	0c 2e       	mov	r0, r28
 11c:	02 c0       	rjmp	.+4      	; 0x122 <blink_leds+0x30>
 11e:	88 0f       	add	r24, r24
 120:	99 1f       	adc	r25, r25
 122:	0a 94       	dec	r0
 124:	e2 f7       	brpl	.-8      	; 0x11e <blink_leds+0x2c>
 126:	97 df       	rcall	.-210    	; 0x56 <led_display>
 128:	18 2b       	or	r17, r24
 12a:	18 bb       	out	0x18, r17	; 24
 12c:	8b 2d       	mov	r24, r11
 12e:	8a 95       	dec	r24
 130:	f1 f7       	brne	.-4      	; 0x12e <blink_leds+0x3c>
            _delay_us(100);
            clear_display();
 132:	88 b3       	in	r24, 0x18	; 24
 134:	80 7f       	andi	r24, 0xF0	; 240
 136:	88 bb       	out	0x18, r24	; 24
 138:	80 2f       	mov	r24, r16
 13a:	8a 95       	dec	r24
 13c:	f1 f7       	brne	.-4      	; 0x13a <blink_leds+0x48>

void blink_leds() {
    uint16_t j;
    uint16_t i;
    for( i = 0; i < 100; i++) {
        for (j = 0; j <= 3; j++) {
 13e:	21 96       	adiw	r28, 0x01	; 1
 140:	c4 30       	cpi	r28, 0x04	; 4
 142:	d1 05       	cpc	r29, r1
 144:	41 f7       	brne	.-48     	; 0x116 <blink_leds+0x24>
}

void blink_leds() {
    uint16_t j;
    uint16_t i;
    for( i = 0; i < 100; i++) {
 146:	08 94       	sec
 148:	e1 1c       	adc	r14, r1
 14a:	f1 1c       	adc	r15, r1
 14c:	84 e6       	ldi	r24, 0x64	; 100
 14e:	e8 16       	cp	r14, r24
 150:	f1 04       	cpc	r15, r1
 152:	19 f0       	breq	.+6      	; 0x15a <blink_leds+0x68>
 154:	c0 e0       	ldi	r28, 0x00	; 0
 156:	d0 e0       	ldi	r29, 0x00	; 0
 158:	de cf       	rjmp	.-68     	; 0x116 <blink_leds+0x24>
            _delay_us(100);
            clear_display();
            _delay_us(10);
        }
    }
}
 15a:	df 91       	pop	r29
 15c:	cf 91       	pop	r28
 15e:	1f 91       	pop	r17
 160:	0f 91       	pop	r16
 162:	ff 90       	pop	r15
 164:	ef 90       	pop	r14
 166:	df 90       	pop	r13
 168:	cf 90       	pop	r12
 16a:	bf 90       	pop	r11
 16c:	08 95       	ret

0000016e <rand_lcg>:
// is constantly fedback into the function when a new random number is desired. 
// Needs some initial seed value.
//
// m, a and c need to be chosen carefully
uint16_t rand_lcg(uint16_t lcg_previous, uint16_t m, uint16_t a, uint16_t c)
{
 16e:	fc 01       	movw	r30, r24
 170:	db 01       	movw	r26, r22
 172:	ca 01       	movw	r24, r20
 174:	bf 01       	movw	r22, r30
 176:	5a d1       	rcall	.+692    	; 0x42c <__mulhi3>
 178:	82 0f       	add	r24, r18
 17a:	93 1f       	adc	r25, r19
 17c:	bd 01       	movw	r22, r26
 17e:	68 d1       	rcall	.+720    	; 0x450 <__udivmodhi4>
    return (lcg_previous*a + c) % m;
}
 180:	08 95       	ret

00000182 <read_adc>:

uint16_t read_adc() {
    // TODO: Make more general and allow channel selection

    // ADCSRA[6]: start single conversion
    ADCSRA |= 0b01000000;
 182:	36 9a       	sbi	0x06, 6	; 6
    
    // Loop until ADIF interrupt occurs
    while(!(ADCSRA & (1 << ADIF)));
 184:	34 9b       	sbis	0x06, 4	; 6
 186:	fe cf       	rjmp	.-4      	; 0x184 <read_adc+0x2>
    
    // Clear ADIF by writing 1 to it
    ADCSRA |= (1<<ADIF);
 188:	34 9a       	sbi	0x06, 4	; 6

    // Return the ADC data
    return ADC;
 18a:	24 b1       	in	r18, 0x04	; 4
 18c:	35 b1       	in	r19, 0x05	; 5
}
 18e:	c9 01       	movw	r24, r18
 190:	08 95       	ret

00000192 <get_player_move>:


uint8_t get_player_move() {
    uint16_t raw_move = read_adc();
 192:	f7 df       	rcall	.-18     	; 0x182 <read_adc>
 194:	9c 01       	movw	r18, r24
    uint8_t move;
    static uint8_t prev_move = 0;
    if ((raw_move >= 500) & (raw_move <= 520)) {
 196:	84 5f       	subi	r24, 0xF4	; 244
 198:	91 40       	sbci	r25, 0x01	; 1
 19a:	45 97       	sbiw	r24, 0x15	; 21
 19c:	10 f4       	brcc	.+4      	; 0x1a2 <get_player_move+0x10>
 19e:	21 e0       	ldi	r18, 0x01	; 1
 1a0:	16 c0       	rjmp	.+44     	; 0x1ce <get_player_move+0x3c>
        move = 0x01;
    } else if ((raw_move >= 600) & (raw_move <= 620)) {
 1a2:	c9 01       	movw	r24, r18
 1a4:	88 55       	subi	r24, 0x58	; 88
 1a6:	92 40       	sbci	r25, 0x02	; 2
 1a8:	45 97       	sbiw	r24, 0x15	; 21
 1aa:	10 f4       	brcc	.+4      	; 0x1b0 <get_player_move+0x1e>
 1ac:	22 e0       	ldi	r18, 0x02	; 2
 1ae:	0f c0       	rjmp	.+30     	; 0x1ce <get_player_move+0x3c>
        move = 0x02;
    } else if ((raw_move >= 660) & (raw_move <= 680)) {
 1b0:	c9 01       	movw	r24, r18
 1b2:	84 59       	subi	r24, 0x94	; 148
 1b4:	92 40       	sbci	r25, 0x02	; 2
 1b6:	45 97       	sbiw	r24, 0x15	; 21
 1b8:	10 f4       	brcc	.+4      	; 0x1be <get_player_move+0x2c>
 1ba:	24 e0       	ldi	r18, 0x04	; 4
 1bc:	08 c0       	rjmp	.+16     	; 0x1ce <get_player_move+0x3c>
        move = 0x04;
    } else if ((raw_move >= 710) & (raw_move <= 730)) {
 1be:	26 5c       	subi	r18, 0xC6	; 198
 1c0:	32 40       	sbci	r19, 0x02	; 2
 1c2:	25 31       	cpi	r18, 0x15	; 21
 1c4:	31 05       	cpc	r19, r1
 1c6:	10 f0       	brcs	.+4      	; 0x1cc <get_player_move+0x3a>
 1c8:	20 e0       	ldi	r18, 0x00	; 0
 1ca:	01 c0       	rjmp	.+2      	; 0x1ce <get_player_move+0x3c>
 1cc:	28 e0       	ldi	r18, 0x08	; 8
    } else {
        move = 0x00;
    }
    
    // Make the reading edge sensitive
    if (move == prev_move)
 1ce:	80 91 64 00 	lds	r24, 0x0064
 1d2:	28 17       	cp	r18, r24
 1d4:	11 f4       	brne	.+4      	; 0x1da <get_player_move+0x48>
 1d6:	20 e0       	ldi	r18, 0x00	; 0
 1d8:	02 c0       	rjmp	.+4      	; 0x1de <get_player_move+0x4c>
        move = 0;
    else
        prev_move = move;
 1da:	20 93 64 00 	sts	0x0064, r18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1de:	8a ef       	ldi	r24, 0xFA	; 250
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	01 97       	sbiw	r24, 0x01	; 1
 1e4:	f1 f7       	brne	.-4      	; 0x1e2 <get_player_move+0x50>
    
    // Try to prevent bouncing
    _delay_us(1000);
    return move;
}
 1e6:	82 2f       	mov	r24, r18
 1e8:	08 95       	ret

000001ea <main>:
uint8_t get_player_move();

enum STATE gamestate = IDLE;

int main (void)
{
 1ea:	2f 92       	push	r2
 1ec:	3f 92       	push	r3
 1ee:	4f 92       	push	r4
 1f0:	5f 92       	push	r5
 1f2:	6f 92       	push	r6
 1f4:	7f 92       	push	r7
 1f6:	8f 92       	push	r8
 1f8:	9f 92       	push	r9
 1fa:	af 92       	push	r10
 1fc:	bf 92       	push	r11
 1fe:	cf 92       	push	r12
 200:	df 92       	push	r13
 202:	ef 92       	push	r14
 204:	ff 92       	push	r15
 206:	0f 93       	push	r16
 208:	1f 93       	push	r17
 20a:	df 93       	push	r29
 20c:	cf 93       	push	r28
 20e:	cd b7       	in	r28, 0x3d	; 61
 210:	de b7       	in	r29, 0x3e	; 62
 212:	c4 56       	subi	r28, 0x64	; 100
 214:	d0 40       	sbci	r29, 0x00	; 0
 216:	0f b6       	in	r0, 0x3f	; 63
 218:	f8 94       	cli
 21a:	de bf       	out	0x3e, r29	; 62
 21c:	0f be       	out	0x3f, r0	; 63
 21e:	cd bf       	out	0x3d, r28	; 61
     */
    uint8_t moves[MAX_MOVES]; 
    uint16_t i; 
    uint16_t cpu_counter = 0; 
    uint16_t player_counter = 0;
    uint16_t random = eeprom_read_word((uint16_t *) 46);
 220:	8e e2       	ldi	r24, 0x2E	; 46
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	29 d1       	rcall	.+594    	; 0x478 <__eerd_word_tn85>
 226:	6c 01       	movw	r12, r24
    uint16_t player_move;
    //    enum STATE gamestate = CPU;
    // Set up PortB pins 0, 1, and 2 to be outputs.
    DDRB = 0x07;
 228:	87 e0       	ldi	r24, 0x07	; 7
 22a:	87 bb       	out	0x17, r24	; 23
    // Set pull down resistors and all pins off.
    PORTB = 0x00;
 22c:	18 ba       	out	0x18, r1	; 24
   
    // Setup the ADC

    // Select ADC2
    ADMUX = 0b00000010; 
 22e:	82 e0       	ldi	r24, 0x02	; 2
 230:	87 b9       	out	0x07, r24	; 7
    // ADCSRA[7]: Set ADEN on.
    // ADCSRA[2:0]: Set to 011 for a divide by 8 clock division. 
    //                (125 kHz ADC clock)
    ADCSRA = 0b10000011;
 232:	83 e8       	ldi	r24, 0x83	; 131
 234:	86 b9       	out	0x06, r24	; 6
 236:	88 24       	eor	r8, r8
 238:	99 24       	eor	r9, r9
 23a:	aa 24       	eor	r10, r10
 23c:	bb 24       	eor	r11, r11
 23e:	49 e1       	ldi	r20, 0x19	; 25
 240:	44 2e       	mov	r4, r20
 242:	51 2c       	mov	r5, r1
 244:	38 ea       	ldi	r19, 0xA8	; 168
 246:	63 2e       	mov	r6, r19
 248:	31 e6       	ldi	r19, 0x61	; 97
 24a:	73 2e       	mov	r7, r19
 24c:	24 ed       	ldi	r18, 0xD4	; 212
 24e:	22 2e       	mov	r2, r18
 250:	20 e3       	ldi	r18, 0x30	; 48
 252:	32 2e       	mov	r3, r18
 254:	04 c0       	rjmp	.+8      	; 0x25e <main+0x74>
 256:	88 24       	eor	r8, r8
 258:	99 24       	eor	r9, r9
 25a:	aa 24       	eor	r10, r10
 25c:	bb 24       	eor	r11, r11

    // And now the games begin!
    while (1) {
        if (gamestate == CPU) {
 25e:	00 91 62 00 	lds	r16, 0x0062
 262:	10 91 63 00 	lds	r17, 0x0063
 266:	01 30       	cpi	r16, 0x01	; 1
 268:	11 05       	cpc	r17, r1
 26a:	09 f0       	breq	.+2      	; 0x26e <__stack+0xf>
 26c:	49 c0       	rjmp	.+146    	; 0x300 <__stack+0xa1>
            // Get a new random number from the lcg
            random = rand_lcg(random, MAX_PERIOD, MULTIPLIER, C ); 
 26e:	c6 01       	movw	r24, r12
 270:	60 e0       	ldi	r22, 0x00	; 0
 272:	70 e8       	ldi	r23, 0x80	; 128
 274:	41 e0       	ldi	r20, 0x01	; 1
 276:	52 e0       	ldi	r21, 0x02	; 2
 278:	21 e0       	ldi	r18, 0x01	; 1
 27a:	30 e0       	ldi	r19, 0x00	; 0
 27c:	78 df       	rcall	.-272    	; 0x16e <rand_lcg>
 27e:	6c 01       	movw	r12, r24
            eeprom_write_word((uint16_t *)46, random); // Store last random value in the EEPROM for next seed, if reset occurs
 280:	8e e2       	ldi	r24, 0x2E	; 46
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	b6 01       	movw	r22, r12
 286:	fd d0       	rcall	.+506    	; 0x482 <__eewr_word_tn85>
            // Store this move into memory. First shift rand over and only take the
            // two most significant bits.
            moves[cpu_counter] = 0x01 << (random >> 13);
 288:	e1 e0       	ldi	r30, 0x01	; 1
 28a:	f0 e0       	ldi	r31, 0x00	; 0
 28c:	ec 0f       	add	r30, r28
 28e:	fd 1f       	adc	r31, r29
 290:	e8 0d       	add	r30, r8
 292:	f9 1d       	adc	r31, r9
 294:	8d 2d       	mov	r24, r13
 296:	82 95       	swap	r24
 298:	86 95       	lsr	r24
 29a:	87 70       	andi	r24, 0x07	; 7
 29c:	02 c0       	rjmp	.+4      	; 0x2a2 <__stack+0x43>
 29e:	00 0f       	add	r16, r16
 2a0:	11 1f       	adc	r17, r17
 2a2:	8a 95       	dec	r24
 2a4:	e2 f7       	brpl	.-8      	; 0x29e <__stack+0x3f>
 2a6:	00 83       	st	Z, r16
 2a8:	ee 24       	eor	r14, r14
 2aa:	ff 24       	eor	r15, r15
            
            for (i = 0; i <= cpu_counter; i++) {
                // Translate the move into something that we can send to the 
                // charlieplexed LEDs
                PORTB |= led_display(moves[i]); 
 2ac:	18 b3       	in	r17, 0x18	; 24
 2ae:	e1 e0       	ldi	r30, 0x01	; 1
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	ec 0f       	add	r30, r28
 2b4:	fd 1f       	adc	r31, r29
 2b6:	ee 0d       	add	r30, r14
 2b8:	ff 1d       	adc	r31, r15
 2ba:	80 81       	ld	r24, Z
 2bc:	cc de       	rcall	.-616    	; 0x56 <led_display>
 2be:	18 2b       	or	r17, r24
 2c0:	18 bb       	out	0x18, r17	; 24
 2c2:	88 e8       	ldi	r24, 0x88	; 136
 2c4:	93 e1       	ldi	r25, 0x13	; 19
 2c6:	f2 01       	movw	r30, r4
 2c8:	31 97       	sbiw	r30, 0x01	; 1
 2ca:	f1 f7       	brne	.-4      	; 0x2c8 <__stack+0x69>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2cc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2ce:	d9 f7       	brne	.-10     	; 0x2c6 <__stack+0x67>
                _delay_ms(500);
                PORTB &= 0xF0;
 2d0:	88 b3       	in	r24, 0x18	; 24
 2d2:	80 7f       	andi	r24, 0xF0	; 240
 2d4:	88 bb       	out	0x18, r24	; 24
 2d6:	c3 01       	movw	r24, r6
 2d8:	01 97       	sbiw	r24, 0x01	; 1
 2da:	f1 f7       	brne	.-4      	; 0x2d8 <__stack+0x79>
            eeprom_write_word((uint16_t *)46, random); // Store last random value in the EEPROM for next seed, if reset occurs
            // Store this move into memory. First shift rand over and only take the
            // two most significant bits.
            moves[cpu_counter] = 0x01 << (random >> 13);
            
            for (i = 0; i <= cpu_counter; i++) {
 2dc:	08 94       	sec
 2de:	e1 1c       	adc	r14, r1
 2e0:	f1 1c       	adc	r15, r1
 2e2:	8e 14       	cp	r8, r14
 2e4:	9f 04       	cpc	r9, r15
 2e6:	10 f7       	brcc	.-60     	; 0x2ac <__stack+0x4d>
                PORTB |= led_display(moves[i]); 
                _delay_ms(500);
                PORTB &= 0xF0;
                _delay_ms(100);
            }
            cpu_counter += 1;
 2e8:	08 94       	sec
 2ea:	81 1c       	adc	r8, r1
 2ec:	91 1c       	adc	r9, r1
            gamestate = PLAYER;
 2ee:	82 e0       	ldi	r24, 0x02	; 2
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	90 93 63 00 	sts	0x0063, r25
 2f6:	80 93 62 00 	sts	0x0062, r24
 2fa:	84 ec       	ldi	r24, 0xC4	; 196
 2fc:	99 e0       	ldi	r25, 0x09	; 9
 2fe:	93 c0       	rjmp	.+294    	; 0x426 <__stack+0x1c7>
            _delay_ms(10);
        } else if (gamestate == PLAYER) {
 300:	02 30       	cpi	r16, 0x02	; 2
 302:	11 05       	cpc	r17, r1
 304:	09 f0       	breq	.+2      	; 0x308 <__stack+0xa9>
 306:	53 c0       	rjmp	.+166    	; 0x3ae <__stack+0x14f>
            player_move = get_player_move(); 
 308:	44 df       	rcall	.-376    	; 0x192 <get_player_move>
 30a:	e8 2e       	mov	r14, r24
 30c:	ff 24       	eor	r15, r15
            if (player_move == 0) {
 30e:	e1 14       	cp	r14, r1
 310:	f1 04       	cpc	r15, r1
 312:	21 f4       	brne	.+8      	; 0x31c <__stack+0xbd>
                clear_display();
 314:	88 b3       	in	r24, 0x18	; 24
 316:	80 7f       	andi	r24, 0xF0	; 240
 318:	88 bb       	out	0x18, r24	; 24
 31a:	a1 cf       	rjmp	.-190    	; 0x25e <main+0x74>
            } else {
                set_display(player_move);               
 31c:	18 b3       	in	r17, 0x18	; 24
 31e:	9b de       	rcall	.-714    	; 0x56 <led_display>
 320:	18 2b       	or	r17, r24
 322:	18 bb       	out	0x18, r17	; 24
 324:	f1 01       	movw	r30, r2
 326:	31 97       	sbiw	r30, 0x01	; 1
 328:	f1 f7       	brne	.-4      	; 0x326 <__stack+0xc7>
                _delay_ms(50);
                clear_display();
 32a:	98 b3       	in	r25, 0x18	; 24
 32c:	90 7f       	andi	r25, 0xF0	; 240
 32e:	98 bb       	out	0x18, r25	; 24
 330:	f1 01       	movw	r30, r2
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	f1 f7       	brne	.-4      	; 0x332 <__stack+0xd3>
                _delay_ms(50);
                set_display(player_move);
 336:	98 b3       	in	r25, 0x18	; 24
 338:	98 2b       	or	r25, r24
 33a:	98 bb       	out	0x18, r25	; 24
 33c:	c1 01       	movw	r24, r2
 33e:	01 97       	sbiw	r24, 0x01	; 1
 340:	f1 f7       	brne	.-4      	; 0x33e <__stack+0xdf>
                _delay_ms(50);
                clear_display();
 342:	88 b3       	in	r24, 0x18	; 24
 344:	80 7f       	andi	r24, 0xF0	; 240
 346:	88 bb       	out	0x18, r24	; 24
                if (player_move == moves[player_counter]) {
 348:	e1 e0       	ldi	r30, 0x01	; 1
 34a:	f0 e0       	ldi	r31, 0x00	; 0
 34c:	ec 0f       	add	r30, r28
 34e:	fd 1f       	adc	r31, r29
 350:	ea 0d       	add	r30, r10
 352:	fb 1d       	adc	r31, r11
 354:	80 81       	ld	r24, Z
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	e8 16       	cp	r14, r24
 35a:	f9 06       	cpc	r15, r25
 35c:	b9 f4       	brne	.+46     	; 0x38c <__stack+0x12d>
                    if (player_counter == (cpu_counter-1)) {
 35e:	c4 01       	movw	r24, r8
 360:	01 97       	sbiw	r24, 0x01	; 1
 362:	a8 16       	cp	r10, r24
 364:	b9 06       	cpc	r11, r25
 366:	71 f4       	brne	.+28     	; 0x384 <__stack+0x125>
 368:	80 e1       	ldi	r24, 0x10	; 16
 36a:	97 e2       	ldi	r25, 0x27	; 39
 36c:	f2 01       	movw	r30, r4
 36e:	31 97       	sbiw	r30, 0x01	; 1
 370:	f1 f7       	brne	.-4      	; 0x36e <__stack+0x10f>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 372:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 374:	d9 f7       	brne	.-10     	; 0x36c <__stack+0x10d>
                        player_counter = 0;
                        _delay_ms(1000);
                        gamestate = CPU;
 376:	81 e0       	ldi	r24, 0x01	; 1
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	90 93 63 00 	sts	0x0063, r25
 37e:	80 93 62 00 	sts	0x0062, r24
 382:	6b cf       	rjmp	.-298    	; 0x25a <main+0x70>
                    } else {   
                        player_counter += 1;
 384:	08 94       	sec
 386:	a1 1c       	adc	r10, r1
 388:	b1 1c       	adc	r11, r1
 38a:	69 cf       	rjmp	.-302    	; 0x25e <main+0x74>
                    }
                } else {
                    player_counter = 0;
                    cpu_counter = 0;
                    
                    gamestate = IDLE;
 38c:	10 92 63 00 	sts	0x0063, r1
 390:	10 92 62 00 	sts	0x0062, r1
                    blink_leds();
 394:	ae de       	rcall	.-676    	; 0xf2 <blink_leds>
 396:	c3 01       	movw	r24, r6
 398:	01 97       	sbiw	r24, 0x01	; 1
 39a:	f1 f7       	brne	.-4      	; 0x398 <__stack+0x139>
                    _delay_ms(100);
                    blink_leds();
 39c:	aa de       	rcall	.-684    	; 0xf2 <blink_leds>
 39e:	88 e8       	ldi	r24, 0x88	; 136
 3a0:	93 e1       	ldi	r25, 0x13	; 19
 3a2:	f2 01       	movw	r30, r4
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	f1 f7       	brne	.-4      	; 0x3a4 <__stack+0x145>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 3a8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 3aa:	d9 f7       	brne	.-10     	; 0x3a2 <__stack+0x143>
 3ac:	54 cf       	rjmp	.-344    	; 0x256 <main+0x6c>
                    _delay_ms(500);

                }
            }
        } else if (gamestate == IDLE) {
 3ae:	01 2b       	or	r16, r17
 3b0:	01 f5       	brne	.+64     	; 0x3f2 <__stack+0x193>
            // When the game is IDLE (not being played), increment the seed.
            // Once random is done being incremented store that value at location
            // 46 in the EEPROM so it can be accessed later.
            random += 0x0001;
 3b2:	08 94       	sec
 3b4:	c1 1c       	adc	r12, r1
 3b6:	d1 1c       	adc	r13, r1
            eeprom_write_word((uint16_t *)46, random);
 3b8:	8e e2       	ldi	r24, 0x2E	; 46
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	b6 01       	movw	r22, r12
 3be:	61 d0       	rcall	.+194    	; 0x482 <__eewr_word_tn85>
            cascade_leds();
 3c0:	60 de       	rcall	.-832    	; 0x82 <cascade_leds>
            if (read_adc() > 200) {
 3c2:	df de       	rcall	.-578    	; 0x182 <read_adc>
 3c4:	89 3c       	cpi	r24, 0xC9	; 201
 3c6:	91 05       	cpc	r25, r1
 3c8:	08 f4       	brcc	.+2      	; 0x3cc <__stack+0x16d>
 3ca:	49 cf       	rjmp	.-366    	; 0x25e <main+0x74>
                gamestate = CPU;
 3cc:	81 e0       	ldi	r24, 0x01	; 1
 3ce:	90 e0       	ldi	r25, 0x00	; 0
 3d0:	90 93 63 00 	sts	0x0063, r25
 3d4:	80 93 62 00 	sts	0x0062, r24
                blink_leds();
 3d8:	8c de       	rcall	.-744    	; 0xf2 <blink_leds>
 3da:	c3 01       	movw	r24, r6
 3dc:	01 97       	sbiw	r24, 0x01	; 1
 3de:	f1 f7       	brne	.-4      	; 0x3dc <__stack+0x17d>
                _delay_ms(100);
                blink_leds();
 3e0:	88 de       	rcall	.-752    	; 0xf2 <blink_leds>
 3e2:	88 e8       	ldi	r24, 0x88	; 136
 3e4:	93 e1       	ldi	r25, 0x13	; 19
 3e6:	f2 01       	movw	r30, r4
 3e8:	31 97       	sbiw	r30, 0x01	; 1
 3ea:	f1 f7       	brne	.-4      	; 0x3e8 <__stack+0x189>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 3ec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 3ee:	d9 f7       	brne	.-10     	; 0x3e6 <__stack+0x187>
 3f0:	36 cf       	rjmp	.-404    	; 0x25e <main+0x74>
                _delay_ms(500);
            }
        } else {
            // Flash LED 1 and 4 if there is an error
            PORTB |= led_display(0x01);
 3f2:	18 b3       	in	r17, 0x18	; 24
 3f4:	81 e0       	ldi	r24, 0x01	; 1
 3f6:	2f de       	rcall	.-930    	; 0x56 <led_display>
 3f8:	18 2b       	or	r17, r24
 3fa:	18 bb       	out	0x18, r17	; 24
 3fc:	c3 01       	movw	r24, r6
 3fe:	01 97       	sbiw	r24, 0x01	; 1
 400:	f1 f7       	brne	.-4      	; 0x3fe <__stack+0x19f>
            _delay_ms(100);
            PORTB &= 0xF0;
 402:	88 b3       	in	r24, 0x18	; 24
 404:	80 7f       	andi	r24, 0xF0	; 240
 406:	88 bb       	out	0x18, r24	; 24
 408:	c3 01       	movw	r24, r6
 40a:	01 97       	sbiw	r24, 0x01	; 1
 40c:	f1 f7       	brne	.-4      	; 0x40a <__stack+0x1ab>
            _delay_ms(100);
            PORTB |= led_display(0x08);
 40e:	18 b3       	in	r17, 0x18	; 24
 410:	88 e0       	ldi	r24, 0x08	; 8
 412:	21 de       	rcall	.-958    	; 0x56 <led_display>
 414:	18 2b       	or	r17, r24
 416:	18 bb       	out	0x18, r17	; 24
 418:	c3 01       	movw	r24, r6
 41a:	01 97       	sbiw	r24, 0x01	; 1
 41c:	f1 f7       	brne	.-4      	; 0x41a <__stack+0x1bb>
            _delay_ms(100);
            PORTB &= 0xF0;
 41e:	88 b3       	in	r24, 0x18	; 24
 420:	80 7f       	andi	r24, 0xF0	; 240
 422:	88 bb       	out	0x18, r24	; 24
 424:	c3 01       	movw	r24, r6
 426:	01 97       	sbiw	r24, 0x01	; 1
 428:	f1 f7       	brne	.-4      	; 0x426 <__stack+0x1c7>
 42a:	19 cf       	rjmp	.-462    	; 0x25e <main+0x74>

0000042c <__mulhi3>:
 42c:	55 27       	eor	r21, r21
 42e:	00 24       	eor	r0, r0

00000430 <__mulhi3_loop>:
 430:	80 ff       	sbrs	r24, 0
 432:	02 c0       	rjmp	.+4      	; 0x438 <__mulhi3_skip1>
 434:	06 0e       	add	r0, r22
 436:	57 1f       	adc	r21, r23

00000438 <__mulhi3_skip1>:
 438:	66 0f       	add	r22, r22
 43a:	77 1f       	adc	r23, r23
 43c:	61 15       	cp	r22, r1
 43e:	71 05       	cpc	r23, r1
 440:	21 f0       	breq	.+8      	; 0x44a <__mulhi3_exit>
 442:	96 95       	lsr	r25
 444:	87 95       	ror	r24
 446:	00 97       	sbiw	r24, 0x00	; 0
 448:	99 f7       	brne	.-26     	; 0x430 <__mulhi3_loop>

0000044a <__mulhi3_exit>:
 44a:	95 2f       	mov	r25, r21
 44c:	80 2d       	mov	r24, r0
 44e:	08 95       	ret

00000450 <__udivmodhi4>:
 450:	aa 1b       	sub	r26, r26
 452:	bb 1b       	sub	r27, r27
 454:	51 e1       	ldi	r21, 0x11	; 17
 456:	07 c0       	rjmp	.+14     	; 0x466 <__udivmodhi4_ep>

00000458 <__udivmodhi4_loop>:
 458:	aa 1f       	adc	r26, r26
 45a:	bb 1f       	adc	r27, r27
 45c:	a6 17       	cp	r26, r22
 45e:	b7 07       	cpc	r27, r23
 460:	10 f0       	brcs	.+4      	; 0x466 <__udivmodhi4_ep>
 462:	a6 1b       	sub	r26, r22
 464:	b7 0b       	sbc	r27, r23

00000466 <__udivmodhi4_ep>:
 466:	88 1f       	adc	r24, r24
 468:	99 1f       	adc	r25, r25
 46a:	5a 95       	dec	r21
 46c:	a9 f7       	brne	.-22     	; 0x458 <__udivmodhi4_loop>
 46e:	80 95       	com	r24
 470:	90 95       	com	r25
 472:	bc 01       	movw	r22, r24
 474:	cd 01       	movw	r24, r26
 476:	08 95       	ret

00000478 <__eerd_word_tn85>:
 478:	a8 e1       	ldi	r26, 0x18	; 24
 47a:	b0 e0       	ldi	r27, 0x00	; 0
 47c:	42 e0       	ldi	r20, 0x02	; 2
 47e:	50 e0       	ldi	r21, 0x00	; 0
 480:	05 c0       	rjmp	.+10     	; 0x48c <__eerd_blraw_tn85>

00000482 <__eewr_word_tn85>:
 482:	12 d0       	rcall	.+36     	; 0x4a8 <__eewr_byte_tn85>
 484:	27 2f       	mov	r18, r23
 486:	11 c0       	rjmp	.+34     	; 0x4aa <__eewr_r18_tn85>

00000488 <__eerd_block_tn85>:
 488:	dc 01       	movw	r26, r24
 48a:	cb 01       	movw	r24, r22

0000048c <__eerd_blraw_tn85>:
 48c:	fc 01       	movw	r30, r24
 48e:	e1 99       	sbic	0x1c, 1	; 28
 490:	fe cf       	rjmp	.-4      	; 0x48e <__eerd_blraw_tn85+0x2>
 492:	06 c0       	rjmp	.+12     	; 0x4a0 <__eerd_blraw_tn85+0x14>
 494:	ff bb       	out	0x1f, r31	; 31
 496:	ee bb       	out	0x1e, r30	; 30
 498:	e0 9a       	sbi	0x1c, 0	; 28
 49a:	31 96       	adiw	r30, 0x01	; 1
 49c:	0d b2       	in	r0, 0x1d	; 29
 49e:	0d 92       	st	X+, r0
 4a0:	41 50       	subi	r20, 0x01	; 1
 4a2:	50 40       	sbci	r21, 0x00	; 0
 4a4:	b8 f7       	brcc	.-18     	; 0x494 <__eerd_blraw_tn85+0x8>
 4a6:	08 95       	ret

000004a8 <__eewr_byte_tn85>:
 4a8:	26 2f       	mov	r18, r22

000004aa <__eewr_r18_tn85>:
 4aa:	e1 99       	sbic	0x1c, 1	; 28
 4ac:	fe cf       	rjmp	.-4      	; 0x4aa <__eewr_r18_tn85>
 4ae:	1c ba       	out	0x1c, r1	; 28
 4b0:	9f bb       	out	0x1f, r25	; 31
 4b2:	8e bb       	out	0x1e, r24	; 30
 4b4:	2d bb       	out	0x1d, r18	; 29
 4b6:	0f b6       	in	r0, 0x3f	; 63
 4b8:	f8 94       	cli
 4ba:	e2 9a       	sbi	0x1c, 2	; 28
 4bc:	e1 9a       	sbi	0x1c, 1	; 28
 4be:	0f be       	out	0x3f, r0	; 63
 4c0:	01 96       	adiw	r24, 0x01	; 1
 4c2:	08 95       	ret

000004c4 <_exit>:
 4c4:	f8 94       	cli

000004c6 <__stop_program>:
 4c6:	ff cf       	rjmp	.-2      	; 0x4c6 <__stop_program>
